## 📑 目录

* [➕ C/C++](#cc)
* [💻 操作系统](#os)
* [☁️ 计算机网络](#computer-network)
* [🌩 网络编程](#network-programming)
* [💾 数据库](#database)
* [⚡️ 算法](#algorithm)
* [📏 设计模式](#design-pattern)
* [⚙️ 链接装载库](#link-loading-library)
* [📚 书籍](#books)
* [🔱 C/C++ 发展方向](#cc-development-direction)
* [💯 复习刷题网站](#review-of-brush-questions-website)
* [📝 面试题目经验](#interview-questions-experience)
* [📆 招聘时间岗位](#recruitment-time-post)
* [👍 内推](#recommend)
* [👬 贡献者](#contributor)
* [🍭 支持赞助](#support-sponsor)
* [📜 License](#license)

<a id="cc"></a>

# ➕ C/C++

## const

#### 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

#### 宏定义 #define 和 const 常量 

宏定义 #define|const 常量
---|---
宏定义，相当于字符替换|常量声明
预处理器处理|编译器处理
无类型安全检查|有类型安全检查
不分配内存|要分配内存
存储在代码段|存储在数据段
可通过 `#undef` 取消|不可取消

### static用法

### inline 内联函数

#### 特征

* 复制代码：把内联函数里面的代码复制到调用内联函数处；
* 节约开销：省去了函数调用开销；
* 类型检查：相较于宏函数的优点；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 优点

1. 节约函数调用开销，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 做安全检查或自动类型转换（同普通函数），而宏定义则不会。 
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

#### 缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 虚函数（virtual）可以是内联函数（inline）吗？

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

### 尽量少使用 `using 指示` 污染命名空间

> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。

### new、delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

#### 定位 new

定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。

### 如何定义一个只能在堆上（栈上）生成对象的类？

> [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

### 静态建立对象
> 例如 A a。静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。

### 动态建立对象
> 例如 a = new A()。第一步，使用operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

### 智能指针
* unique_ptr, 一个指针独占拥有一个对象。
* shared_ptr, 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象。
* week_ptr,  多个指针共享但不拥有某一个对象，通过shared_ptr来构造的。

### 重载，重写和隐藏的作用范围

### 详细解释动态绑定

### 抽象类与纯虚函数

### 内存泄漏相关，不用delete，访问越界

### 类的内存计算
>[C++类对象的内存结构](https://blog.csdn.net/MOU_IT/article/details/89045103)

### C++11新特性，右值引用，移动语义

<a id="os"></a>
# 💻 操作系统

### 进程与线程的区别
* 进程负责资源的分配和管理，进程可以创建多个线程，由线程负责CPU的调度和执行，多个线程可以并发执行。
* 进程拥有独立的虚拟地址空间。进程之间地址是相互隔离的。线程共享进程的虚拟地址空间。
* 进程切换的开销大，线程切换开销小。

### 进程的通信方式
* 管道，有名管道用于任意进程，无名管道用于父子进程
* 信号量，对共享资源进行计数，用于同步进程
* 信号，告知一个进程发生了某个事件
* 消息队列，存放在内核的数据结构
* 共享内存，将一部分内存空间映射到特定的虚拟地址段
* 套接字，传输的数据为字节，需要对数据解析转换成应用级数据

> 进程之间的通信方式以及优缺点来源于：[进程线程面试题总结](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)

> 多进程与多线程间的对比、优劣与选择来自：[多线程还是多进程的选择及区别](https://blog.csdn.net/lishenglong666/article/details/8557215)

### 协程
* 协程，相当于更加轻量化的线程，或者是用户线程。相较于OS线程来说，协程在用户态上进行调度，切换的上下文空间更加轻量。
* 协程需要与一个线程绑定

> [GMP原理与调度](https://www.topgoer.cn/docs/golang/chapter09-11)
### 死锁预防

* 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
* 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
* 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
* 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
* 有序资源分配法
* 银行家算法

### 多进程是怎么工作的，fork实现

### 内存共享的实现，mmap的实现
发出mmap系统调用，导致用户空间到内核空间的上下文切换(第一次上下文切换)。通过DMA引擎将磁盘文件中的内容拷贝到内核空间缓冲区中(第一次拷贝: hard drive ——> kernel buffer)。
mmap系统调用返回，导致内核空间到用户空间的上下文切换(第二次上下文切换)。接着用户空间和内核空间共享这个缓冲区，而不需要将数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区数据发出write系统调用，导致用户空间到内核空间的上下文切换(第三次上下文切换)。将数据从内核空间缓冲区拷贝到内核空间socket相关联的缓冲区(第二次拷贝: kernel buffer ——> socket buffer)。write系统调用返回，导致内核空间到用户空间的上下文切换(第四次上下文切换)。通过DMA引擎将内核空间socket缓冲区中的数据传递到协议引擎(第三次拷贝: socket buffer ——> protocol engine通过mmap实现的零拷贝I/O进行了4次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中包括了2次DMA拷贝和1次CPU拷贝
### 五种IO模型

### select,epoll

### Linux 后台进程和守护进程
<a id="computer-network"></a>

# ☁️ 计算机网络

### TCP与UDP
* TCP需要建立连接，有三次握手和四次挥手
* TCP数据包有序列号和确认号，需要按序发送和按序接收。
* TCP拥有可靠传输机制，UDP是尽最大努力交付。
* TCP有超时重传，丢包重传
* TCP有流量控制和拥塞控制。发送方会根据接收方的缓存空间大小，和网络拥堵情况，动态调整发送数据包的速度。UDP一般以恒定的速度发送数据包。
* TCP面向字节流传输，UDP面向报文传输
* TCP首部开销至少20字节，UDP只有8字节

### TCP粘包
* 固定包长，比较方便，灵活性差
* 添加特殊符号来标记边界，比如FTP使用'\r\n'
* 包头定长，包头指明包体的长度。

### TCP三次握手
![TCP三次握手](./src/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

### TCP四次挥手
![TCP四次挥手](./src/TCP%E5%9B%9B%E6%AC%A1%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

### 加密算法

### 网络攻击

### HTTP
<a id="database"></a>

# 💾 数据库

### 索引失效

1.有or必全有索引;
2.复合索引未用左列字段;
3.like以%开头;
4.需要类型转换;
5.where中索引列有运算;
6.where中索引列使用了函数;
7.如果mysql觉得全表扫描更快时（数据少）;

<a id="algorithm"></a>

# ⚡️ 算法

### 归并排序时间复杂度推导

>[递归式求解时间复杂度](https://blog.csdn.net/flying_all/article/details/94412552)

### 快速排序手写

>[快速排序](https://leetcode.cn/problems/sort-an-array/)


<a id="project"></a>

# 项目

### 项目压测

<a id="regex"></a>

# 正则表达式

<a id="linux"></a>

# Linux

<a id="problem"></a>

# 场景题目

### 位图法记录登录状态

### 如何从几亿个数中找到唯一出现的一个数
